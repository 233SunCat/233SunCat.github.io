---
title: 网络
date: 2021-04-11 14:39:42
categories: 
- 计算机网络
---

可靠传输：能够有序的都到达接受方

TCP使用滑动窗口

学习三个机制：超时重传/快速重传/选择确认/累计确认

> 先了解背景
>
> 超时重传很简单
>
> 超时重传的时间设置是个难点：简单来说时依据多个往返时间确认平均往返时间，超时重传设置比平均往返时间要长一点，记住超时时间时动态设置不断变化的
>
> 以后有必要的时候来了解

> 背景：报文段丢失，会启动超时重传，但是所有都超时重传，延迟太高了
>
> 对超时重传的补充和改进
>
> 快速重传的思想：一个报文段丢失引发多个重复确认，发送方收到多个重复确认不再等待超时机制，发送丢失的报文段
>
> 例子：比如发送M1,M2,M3,M4,M5
>
> M2丢失，M3,M4,M5都发送M1的确认包通知发送方丢失

 

背景：使用累计确认是对接受到的有序报文段确认，但是失序的报文段也在接受发缓存中，长时间的话会触发超时重发机制

选择确认的思想：对失序的报文段也开启通知

再确认报文段中可以开启字段，该字段用来保存失序的边界，以此来通知发送方发送缺少的报文段

 

> 累计确认：对于有序到达接受方大报文段不再一个个发送确认，而是几个一起
>
> 例子：M1,M2,M3,M4,都到了接收方只发送一个M4的确认，发送 方收到后认定M1M2M3M4都收到了
>
> 三次握手：客户端发送一个SYN请求，服务器回应一个SYN+ACK，客户端回应一个ACK(确认包)
> 平常来说客户端发送一个请求，服务器响应一个确认包就可以了
> 问题：客户端请求在网络延迟太高，等发送到服务器时，或许客户端已经关闭，那么服务器就会一直等待浪费资源
> 解决办法：客户端也要回应一个确认包

SYN是用来同步的，ACK是用来应答的
四次释放
SYN改成FIN
为什么连接只有三步，释放却有四步
在服务器第一次应答时，会发送确认包，但是不会关闭发送端口，因为有可能有数据没发送完
等发送完时，会再向客户端发送一个FIN+ACK
问题：为什么客户端在最后发送确认包要等2MS？
原因：确认又可能网络丢失了，所以在2MSL时间内，服务器没有收到客户端确认包就会反复发送FIN+ACK，所以客户端要等下
解决办法：客户端等待TIME_WAIT=2MSL

TCP/UDP的区别：
1.面向连接方面来答
2.可靠方面
3.应用：TCP大量数据，UDP少量数据

TCP/UDP是传输层给协议，上面只有一个应用层

有关套接字:socket



学习拥塞控制最重要的就是理解慢启动与拥塞避免

学习慢启动，拥塞避免机制/快速恢复机制

1.怎么判断发生了网络拥塞？

拥塞时，路由器的队列排满了，来的分组都会丢失，判断依据分组丢失

判断分组丢失：1.当超时重传启动，2.快速重传机制启动(多次确认)

快速重传说明接收方还能接受到其他的，网络拥塞还不算太严重

超时重传说明拥塞严重了

快速恢复机制(与快速快速重传配套):出现拥塞时，拥塞窗口不置为1，而是直接从慢启动门限开始，并且直接使用拥塞避免不用慢启动

网络拥塞也分程度来控制发送

2.具体怎么控制发送到达拥塞？

因为发送窗口不知道整个网络什么时候会发生拥塞，所以要试探性发送数据

慢启动和拥塞避免都是扩大拥塞窗口只不过速度不一样

慢启动是按照指数方式增长

假设cwnd为发送方的拥塞窗口，设置cwnd=1,发送一个报文段，收到报文段确认则cwnd+1,再发送两个报文段

因为发送延时远远小于传输延时，所以近乎指数方式增长

拥塞避免

　　拥塞避免是依据每个往返时间RTT来增加一个MISS大小，实际做法是每收到一个确认cwnd增加一个MISS*(MISS/cwnd).(Miss是一个报文段大小)

 

暂时理解慢启动门限初始值是自己设置，之后的慢启动门限是依据拥塞值一半来设置的

 发送窗口取拥塞窗口与接收方接收窗口较小的一个

浏览器流程：

**基本流程**　

1、浏览器的地址栏输入URL并按下回车。

2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。

3、DNS解析URL对应的IP。

4、根据IP建立TCP连接（三次握手）。

5、HTTP发起请求。

6、服务器处理请求，浏览器接收HTTP响应。

7、渲染页面，构建DOM树。

8、关闭TCP连接（四次挥手）。

HTTP默认端口80，HTTPS默认端口443

**DNS域名解析**

我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。

　　首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。

　　如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。

　　如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。

　　最后迭代查询，按根域服务器 ->顶级域,.cn->第二层域，hb.cn ->子域，www.hb.cn的顺序找到IP地址。

　　递归查询，按上一级DNS服务器->上上级->....逐级向上查询找到IP地址。

**五、浏览器向服务器发送HTTP请求**

　　完整的HTTP请求包含请求起始行、请求头部、请求主体三部分。

**六、浏览器接收响应**

　　服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。

　　状态码主要包括以下部分

　　1xx：指示信息–表示请求已接收，继续处理。

　　2xx：成功–表示请求已被成功接收、理解、接受。

　　3xx：重定向–要完成请求必须进行更进一步的操作。

　　4xx：客户端错误–请求有语法错误或请求无法实现。

　　5xx：服务器端错误–服务器未能实现合法的请求。

　　响应头主要由Cache-Control、 Connection、Date、Pragma等组成。

　　响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。

**七、页面渲染**

　　如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。

　　在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。

　　Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。

　　Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。

　　所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。

> HTTP/HTTPS的区别

HTTPS在HTTP原有的基础上大大增加了安全性(我的理解)SSL/TLS
HTTPS的特点：基于HTTP协议上加入SSL/TLS，加密数据，验证身份，保证数据完整性。(加密：非对称加密/对称加密)

大概的步骤：
1.客户端发送请求https://.....
2.发送端接受到请求，发送端保存一个公钥一个密钥，并且将公钥响应给客户端
3.客户端接收到公钥开始验证，如果是则生成随机值，否警告
4.客户端将随机值用公钥加密，发送给服务端，服务端使用私钥解密得到随机值
5.两个使用对称加密，这个随机值作为加密根据

